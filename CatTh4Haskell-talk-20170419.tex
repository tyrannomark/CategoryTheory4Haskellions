\documentclass[10pt]{beamer}

\usetheme{metropolis}
\usepackage{appendixnumberbeamer}

\usepackage{booktabs}
\usepackage[scale=2]{ccicons}

\usepackage{pgfplots}
\usepgfplotslibrary{dateplot}

\usepackage{xspace}
\newcommand{\MDL}{\textbf{\textsc{mdl}}\xspace}

\usepackage{graphicx}
\usepackage{tikz-cd}

\newcommand{\Cat}[1]{\ensuremath{\underline{\mathbf{#1}}}}
\newcommand{\Obj}[1]{\ensuremath{\mathrm{Obj}(\Cat{#1})}}
\newcommand{\Hom}[3]{\ensuremath{\mathrm{Hom}_{\Cat{#1}}(#2,#3)}}
\newcommand{\Domain}[1]{\ensuremath{\mathbf{Dom}(#1)}}
\newcommand{\Codomain}[1]{\ensuremath{\mathbf{Cod}(#1)}}
\newcommand{\CompCat}[1]{\Cat{\overline{#1}}}
\newcommand{\Comm}[1]{\mathrm{Kom}_{\Cat{#1}}}
\newcommand{\Com}[3]{#3^{#2}}
\newcommand{\SCat}[1]{\Cat{Symms(#1)}}
\newcommand{\FSCat}[1]{\Cat{FSymm(#1)}}
\newcommand{\FkCat}[1]{\Cat{FkSymm(#1)}}
\newcommand{\PkCat}[1]{\Cat{PkSymm(#1)}}
\newcommand{\IrPaths}[1]{\Cat{IrPaths(#1)}}
\newcommand{\FProj}[2]{\ensuremath{W_{\Cat{#1,#2}}}}
\newcommand{\FuncIm}[1]{\mathrm{Im}(#1)}
\newcommand{\term}[1]{\emph{#1}}
\newcommand{\strong}[1]{\textbf{#1}}

\newcommand{\eqnlabel}[1]{\label{eq:#1}}
\newcommand{\eqnref}[1]{(\ref{eq:#1})}
\newcommand{\deflabel}[1]{\label{def:#1}}
\newcommand{\defref}[1]{definition \ref{def:#1}}
\newcommand{\thlabel}[1]{\label{th:#1}}
\newcommand{\thref}[1]{theorem \ref{th:#1}}

% \newcommand{\pullback}{\arrow[d,]}
% \newcommand{\pushout}{\arrow[d,\text{\pigpenfont J}]}

% \newtheorem{threm}{Theorem}[section]
% \newtheorem{lemma}[threm]{Lemma}
\theoremstyle{definition}
% \newtheorem{corollary}[theorem]{Corollary}
% \newtheorem{definition}[theorem]{Definition}
% \newtheorem{example}[theorem]{Example}
\newtheorem{xca}[theorem]{Exercise}

\theoremstyle{remark}
\newtheorem{remark}[theorem]{Remark}

\numberwithin{equation}{section}

%    Absolute value notation
\newcommand{\abs}[1]{\lvert#1\rvert}

%    Blank box placeholder for figures (to avoid requiring any
%    particular graphics capabilities for printing this document).
\newcommand{\blankbox}[2]{%
  \parbox{\columnwidth}{\centering
%    Set fboxsep to 0 so that the actual size of the box will match the
%    given measurements more closely.
    \setlength{\fboxsep}{0pt}%
    \fbox{\raisebox{0pt}[#2]{\hspace{#1}}}%
  }%
}


\title{Category Theory and Haskell}
\subtitle{Parallel Universes}
\date{\today}
\author{Siva Kalyan and T. Mark Ellison}
\institute{Australian National University}
% \titlegraphic{\hfill\includegraphics[height=1.5cm]{logo.pdf}}

\usepackage{listings}
\usepackage{color}
\definecolor{identifierColor}{rgb}{0.65,0.16,0.16}
\lstset{
  frame=none,
  xleftmargin=2pt,
  stepnumber=1,
  numbers=left,
  numbersep=5pt,
  numberstyle=\ttfamily\tiny\color[gray]{0.3},
  belowcaptionskip=\bigskipamount,
  captionpos=b,
  escapeinside={*'}{'*},
  language=haskell,
  tabsize=2,
  emphstyle={\bf},
  commentstyle=\it\color{brown},
  stringstyle=\mdseries\rmfamily\color{green},
  showspaces=false,
  keywordstyle=\bfseries\rmfamily\color{red},
  columns=flexible,
  basicstyle=\small\sffamily\color{blue},
  showstringspaces=false,
  morecomment=[l]\%,
}

\begin{document}

%% SEE https://wiki.haskell.org/wikiupload/8/85/TMR-Issue13.pdf#page=73

\maketitle

\begin{frame}{Table of contents}
  \setbeamertemplate{section in toc}[sections numbered]
  \tableofcontents[hideallsubsections]
\end{frame}


\begin{frame}[fragile]
  \frametitle{Haskell and Category Theory}

  \begin{tabular}{lr}
    \toprule
    Haskell & Category Theory \\
    \midrule
    \textbf{Category} & \textbf{Category} \\
    \textbf{Type} & \textbf{Object} \\
    \textbf{Function} & \textbf{Morphism} \\
    \textbf{\Cat{Hask}} & \textbf{\Cat{Set}} \\
    \textbf{...} & \textbf{Terminal Objects} \\
    \textbf{Value} & \textbf{Global Element} \\
    \textbf{Tuple} & \textbf{Product} \\
    \textbf{Currying, Function Application} & \textbf{Cartesian Closure} \\
    \textbf{Type Constructor, Functor} & \textbf{Functor} \\
    \textbf{...} & \textbf{Natural Transformation} \\
    \textbf{Applicative} & \textbf{...} \\
    \textbf{...} & \textbf{Adjoint Functor Pair} \\
    \textbf{Monad} & \textbf{Monad} \\
    \bottomrule
  \end{tabular}
  

\end{frame}

\section{Categories}

\subsection{Basics}

\begin{frame}[fragile]
  \frametitle{Categories}

  \emph{Categories}

  A \emph{category} $\Cat{C}$ consists of
  \begin{enumerate}
  \item a class $\Obj{C}$ of \emph{objects}, and
  \item for each pair of objects $A,B \in \Obj{C}$, a set $\Hom{C}{A}{B} \in
    \Obj{Set}$ of \emph{arrows} (or \emph{morphisms}) from $A$ to $B$, known as
    a \emph{hom-set}.
  \end{enumerate}\vspace{-1.5\baselineskip}

  \[
    \begin{tikzcd}
      A \arrow[shift left=2]{r}{\Hom{C}{A}{B}} \arrow{r} \arrow[shift right=2]{r} & B
    \end{tikzcd}
  \]

  In Haskell, objects are \emph{types} (\lstinline{Int}, \lstinline{Char}, etc.),
  and arrows are \emph{functions} between types (e.g.\ \lstinline{ord :: Int -> Char}).
\end{frame}

\begin{frame}[fragile]
  \frametitle{Category Laws}
  In a category $\Cat{C}$:
  \begin{enumerate}
  \item Given arrows $f\colon A \rightarrow B$ and $g\colon B \rightarrow C$ in
    $\Cat{C}$, the \emph{composition} $g \circ f \colon A \rightarrow C$ (= \lstinline{g.f}) is also in
    $\Cat{C}$.
  \item Given arrows $f\colon A \rightarrow B$, $g\colon B \rightarrow C$ and $h\colon C \rightarrow D$, $(h \circ
    g) \circ f = h \circ (g \circ f) = h \circ g \circ f$:\vspace{-0.5\baselineskip}
    \[
      \begin{tikzcd}
        A \arrow{r}{f} \arrow[sloped,near end,swap,dashed]{dr}{g \circ f} \arrow[bend
        right=60,sloped,swap,loosely dashed]{drr}{h \circ g \circ f} \arrow[bend
        left=60,sloped,loosely dashed]{drr}{h
          \circ g \circ f} & B \arrow{d}{g}
        \arrow[sloped,near start,dashed]{dr}{h \circ g} & \\
          & C \arrow[swap]{r}{h} & D
      \end{tikzcd}\rlap{.}
    \]
  \item Every object $A \in \Obj{C}$ is associated with an \emph{identity arrow}
    $1_A \colon A \rightarrow A$ (= \lstinline{id}). Given any arrow $f\colon A \rightarrow B$, we have
    \[
      \begin{tikzcd}
        A \arrow[densely dotted]{r}{1_A} \arrow[bend right=30,swap]{rr}{f} & A
        \arrow["f" description]{r}
        \arrow[bend left=30]{rr}{f} & B \arrow[swap,densely dotted]{r}{1_B} & B
      \end{tikzcd}\rlap{.}
    \]
  \end{enumerate}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Examples}

  \begin{center}
    \begin{tabular}{r l l l l}\toprule
    & $\Cat{Set}$ & $\Cat{Hask}$ & $\Cat{POrd}$ & $\Cat{Cat}$ \\\midrule
    \textbf{Objects} & sets & types & items & small cats \\
    \textbf{Morphisms} & functions & functions & $a \leq b$ & functors \\
    \textbf{Composition} & $f \circ g$ & \lstinline!f.g! & transitivity & $F \circ G$ \\
    \textbf{Identity} & $1_A$ & {\lstinline!id!} & $a = a$ & $1_{\Cat{C}}$ \\\bottomrule
  \end{tabular}
  \end{center}

  $\Cat{Hask}$ is \emph{almost} $\Cat{Set}$ ($\Rightarrow$ a type is a ``set of values''),
  but is complicated by the presence of \lstinline{Bottom} ($\bot$) in every type
  (including \lstinline{Void}, which is ``supposed'' to be empty), and the wacky
  behaviour of \lstinline{undefined} with respect to function composition.
\end{frame}

\begin{frame}[fragile]{Category Theory: Terminal Objects}

  \emph{Terminal Objects}

  A \emph{terminal object} is a type $1$ (a.k.a.\ $T$) in $\Obj{C}$, such that there is only a single mapping from any other type $A$ onto that type:

  \[
    \forall A\in \Obj{C}, \left| \Hom{C}{A}{1} \right| = 1.
  \]

  \[
    \begin{tikzcd}[row sep=tiny]
      A \arrow[near start]{dr}{\exists!} & \\
      B \arrow["\exists!" description]{r} & 1\\
      C \arrow[swap,near start]{ur}{\exists!} & 
    \end{tikzcd}
  \]
  
  % Terminal objects in categories:
  % \begin{description}
  %   \item[\Cat{Set}] the singleton set
  %   \item[\Cat{Grp}] the singleton group
  %   \item[\Cat{Top}] the singleton topological space
  %   \item[\Cat{1\downarrow Set}] the singleton pointed set
  %   \item[\Cat{POrd}] the maximum element (if there is one)
  % \end{description}

  In \Cat{Hask}:
  \begin{lstlisting}[frame=single]
    () -- the type corresponding to 1, containing only itself
    terminalMap :: t -> ()
    terminalMap _ = ()
  \end{lstlisting}

\end{frame}

\begin{frame}[fragile,fragile]{Global Elements}
  %% See answer 4 here: http://stackoverflow.com/questions/17380379/where-do-values-fit-in-category-of-hask
  \emph{Global Elements}

  A \emph{global element} of an object $A$ in category $\Cat{C}$ with terminal object $1$ is an arrow $a : 1 \rightarrow A$.
  
  \[
  \begin{tikzcd}
    1 \arrow{r}{a} & A
  \end{tikzcd}
  \]

  In \Cat{Hask}, if we have a value \lstinline{v} in some type \lstinline{A}, we
  can upgrade it to the global element by use of \lstinline{const v}.

  \begin{lstlisting}[frame=single]
    const :: A -> (() -> A)
    const v = \_ -> v
  \end{lstlisting}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Examples}

  \begin{center}
    \begin{tabular}{r l l l l}\toprule
    & $\Cat{Set}$ & $\Cat{Hask}$ & $\Cat{POrd}$ & $\Cat{Cat}$ \\\midrule
    \textbf{Objects} & sets & types & items & small cats \\
    \textbf{Morphisms} & functions & functions & $a \leq b$ & functors \\
    \textbf{Composition} & $f \circ g$ & \lstinline!f.g! & transitivity & $F \circ G$ \\
    \textbf{Identity} & $1_A$ & {\lstinline!id!} & $a = a$ & $1_{\Cat{C}}$ \\
%%    \textbf{Initial obj\rlap{.}} & $\emptyset$ & \texttt{Void} & lwr bnd & $\Cat{0}$ \\
      \textbf{Terminal obj\rlap{.}} & $\{*\}$ & \lstinline!()! & upper bound & $\Cat{1}$ \\\bottomrule
  \end{tabular}
  \end{center}
  
\end{frame}

\begin{frame}[fragile]{Products}

  \emph{Pairwise Products}

  Given objects $A$, $B$ in $\Obj{C}$ there may be a \emph{(pairwise) product}
  $A\sqcap B \in \Obj{C}$ and \emph{projection arrows} $\pi_A \colon A \sqcap B \rightarrow A$ and $\pi_B
  \colon A \sqcap B \rightarrow B$ such that for any object $X \in \Obj{C}$ and arrows $a \colon X \rightarrow
  A$ and $b \colon X \rightarrow B$ there is a \emph{unique} arrow $x : X \rightarrow A \sqcap B$ such that $a = \pi_A \circ x$ and $b = \pi_B \circ x$:

  \[
  \begin{tikzcd}
    A & A\sqcap B \arrow[swap]{l}{\pi_{A}} \arrow{r}{\pi_{B}} & B \\
    & X \arrow[dotted]{u}{\exists! x} \arrow{ul}{a} \arrow[swap]{ur}{b} & 
  \end{tikzcd}\rlap{.}
  \]

  In other words: Given a particular way of mapping $X$ to $A$ and to $B$, there's only \emph{one} way of mapping $X$ to $A \sqcap B$ such that everything's consistent.


\end{frame}

\begin{frame}[fragile]{Products}

  \emph{Pairwise Products}

  Alternatively, the triplet $\langle {A \sqcap B, \pi_A, \pi_B} \rangle$ is a \emph{terminal object}
  in the category whose objects are diagrams of the form
  \[
    \begin{tikzcd}
      A & C \arrow{l} \arrow{r} & B
    \end{tikzcd}\rlap{,}
  \]
  and whose arrows are (commutative) diagrams of the form
  \[
    \begin{tikzcd}[row sep=tiny]
       & C \arrow[bend right=15]{dl} \arrow[bend left=15]{dr} & \\
      A & & B \\
       & D \arrow[bend left=15]{ul} \arrow[swap]{uu}{f} \arrow[bend right=15]{ur} & 
    \end{tikzcd}\rlap{.}
  \]

  % Product in categories:
  % \begin{description}
  %   \item[\Cat{Set}] the set of pairs
  %   \item[\Cat{Grp}] the singleton group
  %   \item[\Cat{1\downarrow Set}] the set of pairs from each subset, picking out the pair of the pointed elements
  %   \item[\Cat{POrd}] the least upper bound element
  % \end{description}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Products in Haskell}
  \begin{lstlisting}[frame=single,mathescape=true]
    (a,b) -- the type containing pairs from types a and b ($A \sqcap B$)
    fst :: (a,b) -> a -- the projection function $\pi_A$
    fst (x,y) = x
    snd :: (a,b) -> b -- the projection function $\pi_B$
    snd (x,y) = y
    mapToA :: c -> a
    mapToB :: c -> b -- any ol' functions
    factorThroughProd :: c -> (a,b)
    factorThroughProd z = (mapToA z, mapToB z)
  \end{lstlisting}

  It should be obvious that\\
  \lstinline{fst.factorThroughProd = mapToA}, and\\
  \lstinline{snd.factorThroughProd = mapToB}.
  
  {\footnotesize (Extra credit: Coproducts. Hint: Disjunctive types.)}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Examples}

  \begin{center}
    \begin{tabular}{r l l l l}\toprule
    & $\Cat{Set}$ & $\Cat{Hask}$ & $\Cat{POrd}$ & $\Cat{Cat}$ \\\midrule
    \textbf{Objects} & sets & types & items & small cats \\
    \textbf{Morphisms} & functions & functions & $a \leq b$ & functors \\
    \textbf{Composition} & $f \circ g$ & \lstinline!f.g! & transitivity & $F \circ G$ \\
    \textbf{Identity} & $1_A$ & {\lstinline!id!} & $a = a$ & $1_{\Cat{C}}$ \\
    \textbf{Initial obj\rlap{.}} & $\emptyset$ & \lstinline!Void! & lower bound & $\Cat{0}$ \\
    \textbf{Terminal obj\rlap{.}} & $\{*\}$ & \lstinline!()! & upper bound & $\Cat{1}$ \\
    \textbf{Product} & $A \times B$ & \lstinline!(a,b)! & $\min(a,b)$ & $\Cat{C} \times \Cat{D}$ \\
    \textbf{Coproduct} & $A \sqcup B$ & \lstinline!Either a b! & $\max(a,b)$ & $\Cat{C} \sqcup \Cat{B}$ \\\bottomrule
  \end{tabular}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Exponential Objects}

  Given objects $A$ and $B$ in $\Obj{C}$, an \emph{exponential object} $B^A$
  (also written $[A \rightarrow B]$) is any object such that for any object $C$ and any
  arrow $f\colon C \sqcap A \rightarrow B$,
  \[
    \begin{tikzcd}
      C \sqcap A \arrow[swap,densely dotted]{d}{\exists!} \arrow{dr}{f} & \\
      B^A \sqcap A \arrow[swap]{r}{\mathrm{eval}_B^A} & B
    \end{tikzcd}\rlap{.}
  \]

  Alternatively, the pair $\langle {B^A,\mathrm{eval}_B^A} \rangle$ constitutes a terminal
  object in the category whose objects are diagrams of the form
  \[
    \begin{tikzcd}
      C \sqcap A \arrow{r} & B
    \end{tikzcd}\rlap{,}
  \]
  and whose arrows are commutative diagrams of the form
  \[
    \begin{tikzcd}[row sep=tiny]
      D \sqcap A \arrow{dd} \arrow[bend left=15]{dr} & \\
      & B \\
      C \sqcap A \arrow[bend right=15]{ur} &
    \end{tikzcd}\rlap{.}
  \]
\end{frame}

\begin{frame}[fragile,fragile]
  \frametitle{Exponential Objects in Haskell}

  In $\Cat{Hask}$, the exponential object of two types \lstinline{a} and
  \lstinline{b} is the \emph{function type} \lstinline{(a -> b)} (which is
  nothing more than the hom-set of \lstinline{a} and \lstinline{b}!). Let's see
  how this satisfies the above definition.

\begin{lstlisting}[frame=single]
eval :: ((a -> b),a) -> b
eval (f,x) = f x
arrow :: (c,a) -> b -- some ol' function
factoredArrow :: (c,a) -> ((a -> b),a)
factoredArrow (y,x) = (\z -> arrow (y,z),x)
\end{lstlisting}
  {\footnotesize{(Spot the currying!)}}

  It should be clear that \lstinline{eval.factoredArrow = arrow} --- and that
  \lstinline{factoredArrow} is the \emph{only} arrow for which this is true.
\end{frame}

\section{Functors}

\begin{frame}[fragile]
  \frametitle{Examples}
  \begin{tabular}{r l l l l}\toprule
    & $\Cat{Set}$ & $\Cat{Hask}$ & $\Cat{POrd}$ & $\Cat{Cat}$ \\\midrule
    \textbf{Objects} & sets & types & items & small cats \\
    \textbf{Morphisms} & functions & functions & $\leq$ & functors \\
    \textbf{Composition} & $\circ$ & \texttt{.} & transitivity & $\circ$ \\
    \textbf{Identity} & $1_A$ & \texttt{id} & $=$ & $1_{\Cat{C}}$ \\
%%    \textbf{Initial obj\rlap{.}} & $\emptyset$ & \texttt{Void} & lwr bnd & $\Cat{0}$ \\
    \textbf{Terminal obj\rlap{.}} & $\{*\}$ & \texttt{()} & uppr bnd & $\Cat{1}$ \\
    \textbf{Product} & $A \times B$ & \texttt{(A,B)} & $\min$ & $\Cat{C} \times \Cat{D}$ \\
%%    \textbf{Coproduct} & $A \sqcup B$ & \texttt{A | B} & $\max$ & $\Cat{C} \sqcup \Cat{B}$ \\
    \textbf{Endofunctors} & functors & type const. & \textsc{opt}s & nat.\ trans.\\\bottomrule
  \end{tabular}
\end{frame}

\section{Natural transformations}

\section{Applicatives}

\begin{frame}[fragile]{Category Theory: Cartesian Closure}

  \emph{Cartesian-Closed Categories (CCC)}

  There is a terminal object $1$.

  There are binary products $\sqcap$.

  There is a bi-functor taking $A,B$ onto $\Com{C}{A}{B}$, obeying the following rules:
  
  \[
  A \cong \Com{C}{1}{A}
  \]
  
  \begin{equation}
  \Hom{C}{A\sqcap B}{C} \cong \Hom{C}{A}{\Com{C}{B}{C}} \eqnlabel{exp1}
  \end{equation}
\end{frame}

\begin{frame}[fragile]{Category Theory: Cartesian Closure}

  \emph{Cartesian-Closed Categories (CCC)}
  include
  \begin{description}
    \item[\Cat{Set}] the singleton set, pairs, sets of functions
    \item[\Cat{Grp}] ?
    \item[\Cat{1\downarrow Set}] ?
    \item[\Cat{POrd}] ?
    \item[\Cat{Hask}] \lstinline{()}, \lstinline{(a,b)}, \lstinline{a -> b}
  \end{description}

\end{frame}

\begin{frame}[fragile]{Category Theory: Cartesian Closure}

  \emph{Cartesian-Closed Categories (CCC)}

  We define the arrow $\lambda$ to be the arrow from $\Com{C}{B}{C}\sqcap B$ to $C$ which corresponds to the identity arrow under the isomorphism in \eqnref{exp1}.

  \[
  \lambda : \Com{C}{B}{C}\sqcap B \rightarrow C \cong 1_{\Com{C}{B}{C}}
  \]

\end{frame}

\begin{frame}[fragile]{Category Theory: Endofunctors in CCCs}

  \emph{Endofunctors in CCCs}

  For any functor $F$, there is a 1-1 correspondence between natural transformations from the identity functor to $F$ and the global elements of $F(1)$. Use the symbol $i$ to index over the global elements of $F(1_{\Cat{C}}$. Then we have the natural transformations:
  
  \[
  \phi_{i,A} : A \rightarrow F A
  \]
  where
  \[
  f : A \rightarrow B, F(f) \circ \phi_{i,A} = \phi_{i,B} \circ f
  \]

\end{frame}

\begin{frame}[fragile]{Category Theory: Applicative Functors}

  \emph{Applicative Functors}

  An \emph{applicative} functor $F$ is a functor $\Cat{C}\rightarrow \Cat{D}$ such that:
  \begin{enumerate}
    \item $\Cat{C}$ is CCC,
    \item $im(F)$ is CCC,
    \item $F$ perserves terminal objects, i.e. $F(1_{\Cat{C}})=1_{\Cat{D}}$,
    \item $F$ perserves products, i.e. $F(A\sqcap B)=F(A)\sqcap F(B)$, and
    \item $F$ perserves the power functor, i.e. $\Com{D}{F A}{(F B)} = F \Com{C}{A}{B}$.
  \end{enumerate}

\end{frame}

\begin{frame}[fragile]{Applicatives}

  \emph{Applicatives in Haskell}

  \begin{lstlisting}[frame=single]
class Functor f => Applicative f where
    -- | Lift a value.
    pure :: a -> f a
    -- | Sequential application.
    (<*>) :: f (a -> b) -> f a -> f b
  \end{lstlisting}

  \lstinline{pure} applies the functor to global elements (arrows from $1$ to $a$).
  \[
  \phi : \Com{Hask}{1}{A} \rightarrow \Com{Hask}{1}{F A}
  \]
  \[
  \phi \circ \epsilon_a \mapsto \epsilon_a'
  \]

  \lstinline{<*>} takes the image of an arrow and of a global element and constructs the image of the composition (also a global element).
  \[
  \psi : (F \Com{Hask}{A}{B})\times\Com{Hask}{1}{F A} \rightarrow \Com{Hask}{1}{F B}
  \]
  \[
  \psi \circ (\epsilon_{f},\epsilon_{a'}) \circ \delta \mapsto \epsilon_b'
  \]

\end{frame}

\begin{frame}[fragile]{Applicatives}

  \emph{The Laws of Applicatives}

  From Wikibooks: \emph{Haskell} chapter on \strong{Applicative Functors}:
  %% https://en.wikibooks.org/wiki/Haskell/Applicative_functors
  
  \begin{enumerate}
  \item \strong{Identity}     \lstinline{pure id <*> v = v}
  \item \strong{Homomorphism} \lstinline{pure f <*> pure x = pure (f x)}
  \item \strong{Interchange}  \lstinline{u <*> pure y = pure ($ y) <*> u}
  \item \strong{Composition}  \lstinline{pure (.) <*> u <*> v <*> w = u <*> (v <*> w)}
  \end{enumerate}

\end{frame}

\begin{frame}[fragile]{Applicatives}

  \emph{The Identity Law}

  \lstinline{pure id <*> v = v}
  \[
  \lambda \circ (\phi \circ H(1_A;1,A^A),H(v;1,F A)) \circ \delta = H(v;1,F A)
  \]

  \[
  \begin{tikzcd}
    1 \arrow{r}{\phi}\arrow{d}[swap]{\epsilon_{1_A},\epsilon_v} & F 1 \arrow{d}{F \epsilon_{1_A},F \epsilon_v} \\
    \Com{C}{A}{A}\times (F A) \arrow{r}{\phi,1} & F (\Com{C}{A}{A}) \times (F A) \arrow{d}{=} \\
    & \Com{C}{F A}{(F A)} \times (F A) \arrow{d}{\lambda_{FA,FA}} \\
    & F A
  \end{tikzcd}
  \]

\end{frame}

\begin{frame}[fragile]{Applicatives}

  \emph{Homomorphism}

  \lstinline{pure f <*> pure x = pure (f x)}

  \[
  \begin{tikzcd}
    1 \arrow{r}{\epsilon_f,\epsilon_x} & \Com{C}{A}{B}\times A \arrow{r}{\phi}\arrow{d}{\lambda_{A,B}} &
    F \Com{C}{A}{B} \times (F A) \arrow{r}{=} & \Com{C}{F A}{(F B)} \times (F A) \arrow{d}{F \lambda_{A,B}} \\
    & B \arrow{rr}{\phi} & & F B
  \end{tikzcd}
  \]

\end{frame}

\begin{frame}[fragile]{Applicatives}

  \emph{Interchange}

  \lstinline{pure f <*> pure x = pure (f x)}

  \[
  \begin{tikzcd}
    1 \arrow{r}{\epsilon_1,v} & \Com{C}{A}{A}\times A \arrow{r}{\lambda_{A,A}} & A
  \end{tikzcd}
  \]

\end{frame}

\begin{frame}[fragile]{Applicatives}

  \emph{Composition}

  \lstinline{pure f <*> pure x = pure (f x)}

  \[
  \begin{tikzcd}
    1 \arrow{r}{\epsilon_1,v} & \Com{C}{A}{A}\times A \arrow{r}{\lambda_{A,A}} & A
  \end{tikzcd}
  \]


\end{frame}

\begin{frame}[fragile]{Applicatives}

  \emph{Cartesian-Closed Categories (CCC)}



\end{frame}

\section{Haskell: Applicatives}

\begin{frame}[fragile]{Applicatives}

  \emph{Applicative Functors}
  aka \emph{Endofunctors on Cartesian-Closed Categories}

  \begin{lstlisting}[frame=single]
class Functor f => Applicative f where
    -- | Lift a value.
    pure :: a -> f a
    -- | Sequential application.
    (<*>) :: f (a -> b) -> f a -> f b
  \end{lstlisting}

  Write $(e_{X,Z},c_{X,Z})$ for the forward and backward natural transformation
  \begin{equation}
    Hom(X\times Y,Z) \cong Hom(X,Z^Y) \mathrm{aka} Hom(- \times Y,-) \cong Hom(-,-^Y)
  \end{equation}
  
\end{frame}

\begin{frame}[fragile]{Applicatives}

  \emph{Applicative Functors Example}

  \begin{lstlisting}[frame=single]
instance Applicative Maybe where
    -- | Apply functor Maybe to value
    pure x = Just x
    -- | Apply domain function via fmap
    Nothing <*> _ = Nothing
    (Just f) <*> something = fmap f something
  \end{lstlisting}

\end{frame}

\begin{frame}[fragile]{Applicatives}

  \emph{Applicative Functors Example}

  \begin{lstlisting}[frame=single]
instance Applicative [] where
    -- | Apply functor [] to value
    pure x = [ x ]
    -- | Apply domain function via fmap
    fs <*> xs = [ f x | f <- fs, x <- xs ]
  \end{lstlisting}

\end{frame}

\begin{frame}[fragile]{Applicatives}

  \emph{Applicative Functor Laws}

  \begin{lstlisting}[frame=single]
               v = pure id <*> v
      pure (f x) = pure f <*> pure x
    u <*> pure y = pure ($ y) <*> u
 u <*> (v <*> w) = pure (.) <*> u <*> v <*> w
  \end{lstlisting}

\end{frame}

\begin{frame}[fragile]{Applicatives}

  \emph{Monoidal Categories}

  In mathematics, a monoidal category (or tensor category) is a category C equipped with a bifunctor
⊗ : C × C → C
  that is associative up to a natural isomorphism, and an object I that is both a left and right identity for ⊗, again up to a natural isomorphism.

  \emph{Cartesian-Closed Categories}

  Have an endofunctor $Ap : \Cat{C}\times\Cat{C} \rightarrow \Cat{C}$ such that $Ap : B^A \times A \mapsto B$, such that $ Ap(f,g) = U(f)$

\end{frame}

\begin{frame}[fragile]{Applicatives}

  \emph{Endofunctors with a strength}

  A strong endofunctor F:C→C over a monoidal category (C,⊗,I) is one which comes with a natural transformation σ:A⊗F(B)→F(A⊗B)σ:A⊗F(B)→F(A⊗B), satisfying some coherence conditions with respect to the associator which I will gloss over. This condition is sometimes also pronounced "FF has a strength".

  A lax monoidal functor F:C→DF:C→D is a functor between two monoidal categories (C,⊗,I)(C,⊗,I) and (D,⊕,J)(D,⊕,J) with natural transformations ϕ:F(A)⊕F(B)→F(A⊗B)ϕ:F(A)⊕F(B)→F(A⊗B) and i:J→F(I)i:J→F(I), again satisfying a coherence condition with respect to the associators.

  A strong monoidal functor F:C→DF:C→D is one in which ϕϕ and ii are natural isomorphisms. That is, F(A⊗B)≃F(A)⊕F(B)F(A⊗B)≃F(A)⊕F(B), with ϕϕ and its inverse describing the isomorphism.

  An applicative functor, in the sense of Haskell programs, is a lax monoidal endofunctor with a strength, with the monoidal structure in question being the Cartesian products. So this is why you get the paradoxical-sounding term "strong lax monoidal functor".
\end{frame}

\section{Maths: Adjoint Functors}

\begin{frame}[fragile]{Adjoint Functors}

%%% An 4-tuple $(F,G,\eta,\varepsilon)$ is an adjunction between  two categories $\Cat{C}$ and $\Cat{D}$ (where {\displaystyle F\colon C\to D} F\colon C\to D is left adjoint to {\displaystyle G\colon D\to C} G\colon D\to C and {\displaystyle \eta } \eta  and {\displaystyle \varepsilon } \varepsilon  are respectively the unit and the counit) always defines a monad {\displaystyle (GF,\eta ,G\varepsilon F)} (GF,\eta ,G\varepsilon F).
$(F,G)$ form an adjoint pair when there is a natural isomorphism
  \[
  Hom(F-,-) \cong_{\Phi} Hom(-,G-)
  \]
  
\end{frame}


\section{Maths: Monads}

\begin{frame}[fragile]{Monads}

An adjunction $(F,G,\eta,\varepsilon)$ between two categories $\Cat{C}$ and $\Cat{D}$ where
\begin{enumerate}
\item $F: \Cat{C}\to \Cat{D}$
\item $G: \Cat{D}\to \Cat{C}$
\item $\varepsilon: GF\to 1_{\Cat{C}}$ is the counit of adjunction
\item $\eta: 1_{\Cat{D}}\to FG$ is the unit of adjunction
\end{enumerate}
gives rise to a monad $(FG,\eta,F\varepsilon G)$.
  
\end{frame}

\begin{frame}[fragile]{Monads}

  $(T,\eta,\mu〉$ is a monad over category $\Cat{C}$.
    Create new category $\Cat{C_K} \subseteq \Cat{C}$ such that:

    \begin{enumerate}
      \item $Obj(\Cat{C_T}) = Obj(\Cat{C})$
      \item $Hom_{\Cat{C_T}}(A,B) = Hom_{\Cat{C}}(A,T B)$
      \item $g \circ_{T} f = \mu_{Z} \circ T g \circ f$
      \item $id_{X_T} = \eta_{X}$
    \end{enumerate}

\end{frame}

%% \begin{equation*}
%% \end{equation*}

\section{Haskell: Monads}

\begin{frame}[fragile]{Monads}

  \emph{Monads}

  \begin{lstlisting}[frame=single]
class Applicative m => Monad m where
    -- | Like g(f(..)) in imperative languages
    (>>=)       :: forall a b. m a -> (a -> m b) -> m b
    -- | Like 'f ; g' in imperative languages
    (>>)        :: forall a b. m a -> m b -> m b
    m >> k      = m >>= \_ -> k
    -- | Inject a value into the monadic type.
    return      :: a -> m a
    return      = pure
  \end{lstlisting}

\end{frame}

\begin{frame}[fragile]{Other Connections}
  \begin{description}
  \item[Arrows] 
  \item[Comonads] 
  \item[Lens] 
  \item[Kleisli Arrows] 
  \item[] 
  \item[] 
  \item[] 
  \end{description}
\end{frame}

\section{Further Reading}

\begin{frame}[fragile]{Further Reading}

  ADD: Milewski, Walters
  
  \nocite{Elkins2009}
  \bibliography{CatTh4Haskell-talk-20170419}
  \bibliographystyle{abbrv}

\end{frame}

\section{Maths: Kleisli}

\begin{frame}[fragile]{Kleisli Adjunctions}

  \emph{Every monad can be constructed from an adjunction}

  If $(F,G,\epsilon,\eta)$ is an \emph{adjunction}, then $(GF,\eta)$ is a \emph{monad}.

  $(T,\eta,\mu〉$ is a monad over category $\Cat{C}$.
    Create new category $\Cat{C_K} \subseteq \Cat{C}$ such that:

    \begin{enumerate}
      \item $Obj(\Cat{C_T}) = Obj(\Cat{C})$
      \item $Hom_{\Cat{C_T}}(A,B) = Hom_{\Cat{C}}(A,T B)$
      \item $g \circ_{T} f = \mu_{Z} \circ T g \circ f $
      \item $id_{TX} = \eta_{X} $
    \end{enumerate}

    Now define a functor $ F : \Cat{C} \rightarrow \Cat{C_T} $ such that $ F(X) = X, F(f:X\rightarrow Y) = \eta_Y\circ f$.
    and also a functor $ G : \Cat{C_T} \rightarrow \Cat{C} $ such that $ G(X) = X, G(f:X\rightarrow TY) = \mu_Y\circ Tf$.

    These functors can be shown form an adjoint pair $(F,G,\varepsilon,\phi)$ where $\varepsilon_{Y} = id_{TY}$ and $T = GF$.
    
\end{frame}

\end{document}
